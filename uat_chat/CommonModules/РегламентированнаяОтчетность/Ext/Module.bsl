
//==================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБЩЕГО НАЗНАЧЕНИЯ

//#Если Клиент Тогда
	
// Дополняет строку указанным символом до указанной длины
//
// Параметры: 
//  Стр            - Дополняемая строка
//  Длина          - Требуемая длина результирующей строки
//  Чем            - Символ, которым дополняется строка
//
// Возвращаемое значение:
//  Строка дополненная указанным символом до указанной длины
//
Функция ДополнитьСтроку(Знач Стр, Длина, Чем=" ", Режим = 0) Экспорт
	
	СимволовДополнить = Длина -  СтрДлина(Стр);
	Добавок = "";
	Для Н=1 по СимволовДополнить Цикл
		Добавок =	Добавок + Чем;
	КонецЦикла;
	Возврат ?(Режим=0, Добавок + Стр, Стр + Добавок);
	
КонецФункции 

// Выполняет преобразование цифры в римскую нотацию 
//
// Параметры
//		Цифра - число, целое, от 0 до 9
//      РимскаяЕдиница,РимскаяПятерка,РимскаяДесятка - строки, соответствующие римские цифры
//
// Возвращаемое значение
//		строка
//
// Описание
//		записывает "обычную" цифру римскими цифрами,
//		например:
//				ПреобразоватьЦифруВРимскуюНотацию(7,"I","V","X") = "VII"
//
Функция ПреобразоватьЦифруВРимскуюНотацию(Цифра,РимскаяЕдиница,РимскаяПятерка,РимскаяДесятка) Экспорт

	РимскаяЦифра="";
	Если Цифра = 1 Тогда
	   РимскаяЦифра = РимскаяЕдиница
	ИначеЕсли Цифра = 2 Тогда
	   РимскаяЦифра = РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 3 Тогда
	   РимскаяЦифра = РимскаяЕдиница + РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 4 Тогда
	   РимскаяЦифра = РимскаяЕдиница + РимскаяПятерка;
	ИначеЕсли Цифра = 5 Тогда
	   РимскаяЦифра = РимскаяПятерка;
	ИначеЕсли Цифра = 6 Тогда
	   РимскаяЦифра = РимскаяПятерка + РимскаяЕдиница;
	ИначеЕсли Цифра = 7 Тогда
	   РимскаяЦифра = РимскаяПятерка + РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 8 Тогда
	   РимскаяЦифра = РимскаяПятерка + РимскаяЕдиница + РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 9 Тогда
	   РимскаяЦифра = РимскаяЕдиница + РимскаяДесятка;
	КонецЕсли;
	Возврат РимскаяЦифра;

КонецФункции //ПреобразоватьЦифруВРимскуюНотацию

// Выполняет преобразование арабского числа в римское 
//
// Параметры
//		АрабскоеЧисло - число, целое, от 0 до 999
//
// Возвращаемое значение
//		строка
//
// Описание
//		записывает "обычное" число римскими цифрами,
//		например:
//				ПреобразоватьЧислоВРимскуюНотацию(17) = "ХVII"
//
Функция ПреобразоватьЧислоВРимскуюНотацию(АрабскоеЧисло) Экспорт
    
	РимскоеЧисло="";
	cRab = ДополнитьСтроку(АрабскоеЧисло,3);

	c1 = "1";c5 = "У";c10 = "Х";c50 = "Л";c100 ="С";c500 = "М";c1000 = "Д";

	nEd = Число(Сред(cRab,3,1));
	nDs = Число(Сред(cRab,2,1));
	nSt = Число(Сред(cRab,1,1));

	РимскоеЧисло = РимскоеЧисло + ПреобразоватьЦифруВРимскуюНотацию(nSt,c100,c500,c1000);
	РимскоеЧисло = РимскоеЧисло + ПреобразоватьЦифруВРимскуюНотацию(nDs,c10,c50,c100);
	РимскоеЧисло = РимскоеЧисло + ПреобразоватьЦифруВРимскуюНотацию(nEd,c1,c5,c10);

	Возврат РимскоеЧисло;
	
КонецФункции //ПреобразоватьЧислоВРимскуюНотацию

// Выполняет преобразование римского числа в арабское
//
// Параметры
//		РимскоеЧисло - строка, число, записанное римскими цифрами
//
// Возвращаемое значение
//		число
//
// Описание
//		преобразует число, записанное римскими цифрами, в "обычное" число,
//		например:
//				ПреобразоватьЧислоВАрабскуюНотацию("ХVII") = 17
//
Функция ПреобразоватьЧислоВАрабскуюНотацию(РимскоеЧисло) Экспорт
    
	АрабскоеЧисло=0;

	c1 = "1";c5 = "У";c10 = "Х";c50 = "Л";c100 ="С";c500 = "М";c1000 = "Д";

	РимскоеЧисло = СокрЛП(РимскоеЧисло);
	ЧислоСимволов = СтрДлина(РимскоеЧисло);

	Для Сч=1 По ЧислоСимволов Цикл
	   Если Сред(РимскоеЧисло,Сч,1) = c1000 Тогда
	      АрабскоеЧисло = АрабскоеЧисло+1000;
	   ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c500 Тогда
	      АрабскоеЧисло = АрабскоеЧисло+500;
	   ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c100 Тогда
	      Если (Сч < ЧислоСимволов) И ((Сред(РимскоеЧисло,Сч+1,1) = c500) ИЛИ (Сред(РимскоеЧисло,Сч+1,1) = c1000)) Тогда
	         АрабскоеЧисло = АрабскоеЧисло-100;
	      Иначе
	         АрабскоеЧисло = АрабскоеЧисло+100;
	      КонецЕсли;
	   ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c50 Тогда
	      АрабскоеЧисло = АрабскоеЧисло+50;
	   ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c10 Тогда
	      Если (Сч < ЧислоСимволов) И ((Сред(РимскоеЧисло,Сч+1,1) = c50) ИЛИ (Сред(РимскоеЧисло,Сч+1,1) = c100)) Тогда
	         АрабскоеЧисло = АрабскоеЧисло-10;
	      Иначе
	         АрабскоеЧисло = АрабскоеЧисло+10;
	      КонецЕсли;
	   ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c5 Тогда
	      АрабскоеЧисло = АрабскоеЧисло+5;
	   ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c1 Тогда
	      Если (Сч < ЧислоСимволов) И ((Сред(РимскоеЧисло,Сч+1,1) = c5) ИЛИ (Сред(РимскоеЧисло,Сч+1,1) = c10)) Тогда
	         АрабскоеЧисло = АрабскоеЧисло-1;
	      Иначе
	         АрабскоеЧисло = АрабскоеЧисло+1;
	      КонецЕсли;
	   КонецЕсли;
	КонецЦикла;
	Возврат АрабскоеЧисло;
КонецФункции //ПреобразоватьЧислоВАрабскуюНотацию

//Проверяет на наличие только русских букв (допускаются пробелы и дефис и некоторые спец символы)
Функция СтрокаНаписанаПоРусски(Знач СтрокаПараметр) Экспорт

	СтрокаПараметр = СокрЛП(СтрокаПараметр);	

	СписокДопустимыхЗначений = Новый СписокЗначений;
	СписокДопустимыхЗначений.Добавить(184); 
	СписокДопустимыхЗначений.Добавить(168);
	СписокДопустимыхЗначений.Добавить(45);
	СписокДопустимыхЗначений.Добавить(46);
	СписокДопустимыхЗначений.Добавить(32);
	СписокДопустимыхЗначений.Добавить(48);
	СписокДопустимыхЗначений.Добавить(49);
	СписокДопустимыхЗначений.Добавить(50);
	СписокДопустимыхЗначений.Добавить(51);
	СписокДопустимыхЗначений.Добавить(52);
	СписокДопустимыхЗначений.Добавить(53);
	СписокДопустимыхЗначений.Добавить(54);
	СписокДопустимыхЗначений.Добавить(55);
	СписокДопустимыхЗначений.Добавить(56);
	СписокДопустимыхЗначений.Добавить(57);

	Для Сч=1 По СтрДлина(СтрокаПараметр) Цикл
		Код = КодСимвола(СтрокаПараметр,Сч);
		Если (Код<192) И (СписокДопустимыхЗначений.НайтиПоЗначению(Код) = Неопределено) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	Возврат Истина;
КонецФункции 

// Проверяет, написана ли строка только русскими и латинскими буквами 
//
// Параметры:
//  СтрокаПараметр - строка, проверяемая строка.
//
// Возвращаемое значение:
//		Истина - строка состоит из допустимых символов
//		Ложь - в строке встречаются недопустимые символы
// 
// Описание:
//		Строка проверяется на наличие только русских и латинских букв;
//		кроме того,	допускаются дефис, "Ё", "ё".
//
Функция СтрокаНаписанаРусскимиИлиЛатинскими(Знач СтрокаПараметр) Экспорт
	
	СтрокаПараметр = СокрЛП(СтрокаПараметр);	

	Русские = 0;     
	КоличествоСимволов = СтрДлина(СтрокаПараметр);
	
	Если  КоличествоСимволов > 0 Тогда
		ПервыйСимвол = КодСимвола(Лев(СтрокаПараметр,1)); 
		Если  (ПервыйСимвол >= 192) или (ПервыйСимвол = 184) или (ПервыйСимвол = 168) Тогда
			Русские = 1;
		КонецЕсли;
	КонецЕсли;
	
	СписокДопустимыхЗначений = Новый СписокЗначений;
	СписокДопустимыхЗначений.Добавить(184);   // ё
	СписокДопустимыхЗначений.Добавить(168);   // Ё
	СписокДопустимыхЗначений.Добавить(45);   //  "-"

	Для Сч = 1 По КоличествоСимволов Цикл
		Код = КодСимвола(Сред(СтрокаПараметр,Сч));   
		// Большие латинские буквы: 65 - 90
		// Маленькие латинские буквы: 97 - 122
		// Русские буквы: 192 и больше
		
		//русские:
		Если (Русские = 1) Тогда
			Если (СписокДопустимыхЗначений.НайтиПоЗначению(Код) = Неопределено) и (Код < 192)  Тогда
				Возврат 0;
			КонецЕсли;

		// латинские:	
		Иначе 
			Если (Код <> 45) и 
			((Код < 65) или	(Код > 90) и (Код < 97) или (Код > 122))  Тогда    
				Возврат 0;
			КонецЕсли;
		КонецЕсли;
			
	КонецЦикла;
	
	Возврат 1;

КонецФункции // СтрокаНаписанаРусскимиИлиЛатинскими()

//Выполняет в строке ГДЕ замену символов ЧТО на соответствующие по номерам символы из строки НаЧто
Функция ЗаменитьОдниСимволыДругими(Что,Где,НаЧто) Экспорт
	Рез = Где;
	Для Сч=1 По СтрДлина(Что) Цикл
		Рез = СтрЗаменить(Рез,Сред(Что,Сч,1),Сред(НаЧто,Сч,1));
	КонецЦикла;
	Возврат Рез;
КонецФункции

//==================================================================================
// ПРОЦЕДУРЫ ПРЕОБРАЗОВАНИЯ ЗНАЧЕНИЙ

//Функция раскладывает строку с данными о месте рождения на элементы структуры
Функция РазложитьМестоРождения(Знач СтрокаМестоРождения, ВерхнийРегистр = Истина) Экспорт

	Особое = 0;НаселенныйПункт	= "";Район	= "";Область	= "";Страна	= "";

	//МассивМестоРождения	=	РазложитьСтрокуВМассивПодстрок(Врег(СтрокаМестоРождения));
	МассивМестоРождения	= уатОбщегоНазначенияТиповые.РазложитьСтрокуВМассивПодстрок(?(ВерхнийРегистр, Врег(СтрокаМестоРождения), СтрокаМестоРождения));
	
	ЭлементовВМассиве = МассивМестоРождения.Количество();   
	Если ЭлементовВМассиве	>	0	тогда
		Если СокрЛП(МассивМестоРождения[0]) = "1" тогда
			Особое	=	1;
		КонецЕсли;	 
	КонецЕсли;
	Если ЭлементовВМассиве	>	1	тогда
		НаселенныйПункт	=	СокрЛП(МассивМестоРождения[1]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	2	тогда
		Район	=	СокрЛП(МассивМестоРождения[2]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	3	тогда
		Область	=	СокрЛП(МассивМестоРождения[3]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	4	тогда
		Страна	=	СокрЛП(МассивМестоРождения[4]);
	КонецЕсли;

	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("Особое",Особое);
	СтруктураВозврата.Вставить("НаселенныйПункт",НаселенныйПункт);
	СтруктураВозврата.Вставить("Район",Район);
	СтруктураВозврата.Вставить("Область",Область);
	СтруктураВозврата.Вставить("Страна",Страна);
	Возврат СтруктураВозврата;
	
КонецФункции	 

//Функция раскладывает строку с данными об адресе (в формате 9 запятых) на элементы структуры
Функция РазложитьАдрес(Знач СтрокаАдрес) Экспорт
	
	Страна = "";
	Индекс = "";
	Регион = "";
	Район = "";
	Город = "";
	НаселенныйПункт = "";
	Улица ="";
	Дом ="";
	Корпус ="";
	Квартира ="";

	МассивАдрес	=	уатОбщегоНазначенияТиповые.РазложитьСтрокуВМассивПодстрок(СтрокаАдрес);
	ЭлементовВМассиве = МассивАдрес.Количество();   

	Если ЭлементовВМассиве	>	0	тогда
		Страна	=	СокрЛП(МассивАдрес[0]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	1	тогда
		Индекс	=	СокрЛП(МассивАдрес[1]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	2	тогда
		Регион	=	СокрЛП(МассивАдрес[2]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	3	тогда
		Район	=	СокрЛП(МассивАдрес[3]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	4	тогда
		Город	=	СокрЛП(МассивАдрес[4]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	5	тогда
		НаселенныйПункт	=	СокрЛП(МассивАдрес[5]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	6	тогда
		Улица	=	СокрЛП(МассивАдрес[6]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	7	тогда
		Дом	=	СокрЛП(МассивАдрес[7]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	8	тогда
		Корпус	=	СокрЛП(МассивАдрес[8]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	9	тогда
		Квартира	=	СокрЛП(МассивАдрес[9]);
	КонецЕсли;

	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("Страна",Страна);
	СтруктураВозврата.Вставить("Индекс",Индекс);
	СтруктураВозврата.Вставить("Регион",Регион);
	СтруктураВозврата.Вставить("Район",Район);
	СтруктураВозврата.Вставить("Город",Город);
	СтруктураВозврата.Вставить("НаселенныйПункт",НаселенныйПункт);
	СтруктураВозврата.Вставить("Улица",Улица);
	СтруктураВозврата.Вставить("Дом",Дом);
	СтруктураВозврата.Вставить("Корпус",Корпус);
	СтруктураВозврата.Вставить("Квартира",Квартира);

	Возврат СтруктураВозврата;
	
КонецФункции	 

//Собирает из элементов структуры адреса строку записи адреса в формате 9 запятых
Функция СобратьАдрес(Знач СтруктураАдрес) Экспорт

	Возврат ""+ СтруктураАдрес.Страна + "," + СтруктураАдрес.Индекс + ","+ СтруктураАдрес.Регион + ","
	+ СтруктураАдрес.Район  + "," + СтруктураАдрес.Город  + ","+ СтруктураАдрес.НаселенныйПункт + ","
	+ СтруктураАдрес.Улица  + "," + СтруктураАдрес.Дом    + ","+ СтруктураАдрес.Корпус + "," + СтруктураАдрес.Квартира

КонецФункции	 

//Разбивает серию документа удостоверяющего личность на 2 части: до и после разделителя
Функция РазложитьСериюДокумента(Знач ВидДокумента, Знач СерияДокумента) Экспорт

	Часть1 = "";
	Часть2 = "";
	
	Если  ЗначениеЗаполнено(ВидДокумента) тогда
		
		КодДока = ВидДокумента.КодИМНС;

		Если (КодДока = "01") или (КодДока = "03")  Тогда
			//Свидетельство о рождении или Паспорт гражданина СССР. . Разделитель групп - "-"
			Разделитель = Найти(СерияДокумента, "-");
			Часть1 = ?(Разделитель = 0, СерияДокумента, ЗаменитьОдниСимволыДругими("1УХЛС", ВРег(СокрЛП(Лев(СерияДокумента, Разделитель-1))), "IVXLC"));
			Часть2 = ?(Разделитель = 0, "", СокрЛП(Сред(СерияДокумента, Разделитель + 1)));
		ИначеЕсли (КодДока = "02") Или (КодДока = "22") Тогда
			//Загранпаспорт гражданина СССР и РФ - первая часть не заполняется, заполняется только вторая часть
			Часть2 = СерияДокумента;
		ИначеЕсли КодДока = "21"  Тогда
			//Паспорт гражданина Российской Федерации. Разделитель групп - " "
			Разделитель = Найти(СерияДокумента, " ");
			Часть1 = ?(Разделитель = 0, СерияДокумента, СокрЛП(Лев(СерияДокумента, Разделитель - 1)));
			Часть2 = ?(Разделитель = 0, "", СокрЛП(Сред(СерияДокумента, Разделитель + 1)));
		Иначе	
			Часть1 = СерияДокумента;
		КонецЕсли;
		
	КонецЕсли;	 

	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("Часть1",Часть1);
	СтруктураВозврата.Вставить("Часть2",Часть2);
	Возврат СтруктураВозврата;
	
КонецФункции	 

//Представляет адрес в "удобочитаемом" виде	для отражения в формах
//
//	Параметры: 
//		АдреснаяСтрока (строка), адрес представление которого нужно вернуть.
//		Способ - способ представления адреса (если=1, то возвращает представление адреса без индекса)
//
//	Возвращаемое значение:
//		строку - представление адреса
//
//	Описание:
//		Предназначена для формирования адресной строки в "удобочитаемом" виде
//		для отражения в формах.
//
Функция ПредставлениеАдреса(Знач АдреснаяСтрока, Способ = 0, ПредставлениеПустого = "<<Адрес не задан>>") Экспорт

	Если НЕ ЗначениеЗаполнено(СтрЗаменить(АдреснаяСтрока,",","")) Тогда
		Возврат ПредставлениеПустого;
	КонецЕсли;

	СтруктураАдрес = РазложитьАдрес(АдреснаяСтрока);
	Если АдресСоответствуетТребованиям(СтруктураАдрес) Тогда
		Адрес = "";
		Если ЗначениеЗаполнено(СтруктураАдрес.Страна) Тогда
			СсылкаНаСтрану = Справочники.КлассификаторСтранМира.НайтиПоКоду(СтруктураАдрес.Страна);
			Если НЕ СсылкаНаСтрану.Пустая() Тогда
				Адрес = Адрес +", "+ СсылкаНаСтрану.Наименование;
			Иначе
				Адрес = Адрес +", "+ СтруктураАдрес.Страна;
			КонецЕсли;
		КонецЕсли;

		Если ЗначениеЗаполнено(СтруктураАдрес.Индекс)и(Способ<>1) тогда
			Адрес = Адрес + СтруктураАдрес.Индекс;
		КонецЕсли;	 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Регион),", "+СтруктураАдрес.Регион,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Район),", "+СтруктураАдрес.Район,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Город),", "+СтруктураАдрес.Город,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.НаселенныйПункт),", "+СтруктураАдрес.НаселенныйПункт,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Улица),", "+СтруктураАдрес.Улица,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Дом),", д."+СтруктураАдрес.Дом,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Корпус),", корп. "+СтруктураАдрес.Корпус,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Квартира),", кв. "+СтруктураАдрес.Квартира,""); 

		Адрес = Сред(Адрес,1);//Убрали первую запятую
	Иначе
		Адрес = СтрЗаменить(АдреснаяСтрока, Символы.ПС, ", ");
	КонецЕсли;
	Возврат Адрес;
КонецФункции	// глПредставлениеАдреса

//Возвращает строковое представление места рождения
Функция ПредставлениеМестаРождения(Знач СтрокаМестоРождения) Экспорт

	СтруктураМестоРождения = РазложитьМестоРождения(СтрокаМестоРождения, Ложь);

    Если СтруктураМестоРождения.Особое = 1 Тогда
	
		Представление	=	"особое" +
		?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.НаселенныйПункт),		"",	"  "	+	СокрЛП(СтруктураМестоРождения.НаселенныйПункт))
		+?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.Район),	"",	"  "	+	СокрЛП(СтруктураМестоРождения.Район))
		+?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.Область),	"",	"  "	+	СокрЛП(СтруктураМестоРождения.Область))
		+?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.Страна),	"",	"  "	+	СокрЛП(СтруктураМестоРождения.Страна));
	
	Иначе
	
		Представление	= "" + ?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.НаселенныйПункт),		"",	"Населенный пункт: " + СокрЛП(СтруктураМестоРождения.НаселенныйПункт))
		+?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.Район),	"",	", район:  " + СокрЛП(СтруктураМестоРождения.Район))
		+?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.Область),	"",	", область: "	+	СокрЛП(СтруктураМестоРождения.Область))
		+?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.Страна),	"",	", страна: "	+	СокрЛП(СтруктураМестоРождения.Страна));
		
		Если Лев(Представление, 1) = ","  Тогда
			Представление = Сред(Представление, 2)
		КонецЕсли;
			
	КонецЕсли; 

	Возврат Представление;
КонецФункции	 

//==================================================================================
// ПРОЦЕДУРЫ ПРОВЕРКИ КОРРЕКТНОСТИ ЗАПОЛНЕНИЯ ДАННЫХ

//Проверяет правильность заполнения номера документа, удостоверяющего личность
Функция ПроверитьНомерУдостоверенияЛичности(ДокументКодИМНС, Знач Номер, СтрОшибка) Экспорт

	Если ПустаяСтрока(ЗаменитьОдниСимволыДругими("0123456789",Номер,"          "))=0 Тогда
		СтрОшибка = "В номере документа присутствуют недопустимые символы!";
		Возврат Ложь;
	КонецЕсли;

    ДлинаНомера = СтрДлина(СокрЛП(Номер));
	
	СтрОшибка = "";
	
	Если Найти("01,03,04,06,21",ДокументКодИМНС) <> 0 Тогда
		Если ДлинаНомера <> 6 Тогда
			СтрОшибка = "Номер документа должен состоять из 6 символов!";
			Возврат Ложь;
		КонецЕсли;
	ИначеЕсли Найти("09,22",ДокументКодИМНС) <> 0 Тогда
		Если ДлинаНомера <> 7 Тогда
			СтрОшибка = "Номер документа должен состоять из 7 символов!";
			Возврат Ложь;
		КонецЕсли;
	ИначеЕсли Найти("02,07,27,26",ДокументКодИМНС) <> 0 Тогда
		Если (ДлинаНомера < 6 ) или ( ДлинаНомера > 7 ) Тогда
			СтрОшибка = "Номер документа должен состоять из 6 или 7 символов!";
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции 

// Проверяет правильность заполнения серии документа, удостоверяющего личность 
Функция ПроверитьСериюУдостоверенияЛичности(ДокументКодИМНС, Знач Серия , СтрОшибка) Экспорт

	// проверка
	Если Найти("01,03",ДокументКодИМНС)<>0 Тогда
		ТипДока = 1;
	ИначеЕсли Найти("04,06,07,26,27",ДокументКодИМНС)<>0 Тогда
		ТипДока = 2;
	ИначеЕсли Найти("02,09,22",ДокументКодИМНС)<>0 Тогда
		ТипДока = 3;
	ИначеЕсли Найти("21",ДокументКодИМНС)<>0 Тогда
		ТипДока = 4;
	Иначе
		ТипДока = 5;
	КонецЕсли;
	
	СтрОшибка = "";
	
	Серия = СокрЛП(Серия);
	
	Если ТипДока = 1 Тогда // паспорт СССР и свид о рожд

		Поз = Найти(Серия,"-");
		Если Поз=0 Тогда
			СтрОшибка = "Серия документа должна состоять из двух частей, разделенных символом ""-""!";
			Возврат Ложь;
		КонецЕсли;

		Ч1 = Лев(Серия, Поз-1);
		Ч2 = СокрЛП(Сред(Серия, Поз+1));

		Поз = Найти(Ч2,"-");
		Если Поз <> 0 Тогда
			СтрОшибка = "В серии документа должно быть только две группы символов!";
			Возврат Ложь;
		КонецЕсли;

		Если ПустаяСтрока(Ч1) Тогда
			СтрОшибка = "В серии документа отсутствует числовая часть!";
			Возврат Ложь;
		ИначеЕсли  ПустаяСтрока(ЗаменитьОдниСимволыДругими("IVXLC1УХЛС",Ч1,"          "))=0 Тогда
			СтрОшибка = "Числовая часть серии документа должна указываться символами 1 У Х Л С  или  I V X L C";
			Возврат Ложь;
		ИначеЕсли ЗаменитьОдниСимволыДругими("IVXLC",Ч1,"1УХЛС") <> ПреобразоватьЧислоВРимскуюНотацию(ПреобразоватьЧислоВАрабскуюНотацию(ЗаменитьОдниСимволыДругими("IVXLC",Ч1,"1УХЛС"))) Тогда
			СтрОшибка = "Числовая часть серии документа указана некорректно!";
			Возврат Ложь;
		ИначеЕсли (СтрДлина(Ч2) <> 2) ИЛИ (ПустаяСтрока(ЗаменитьОдниСимволыДругими("АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ",Ч2,"                                 "))=0) Тогда
			СтрОшибка = "После разделителя ""-"" в серии документа должны быть ДВЕ pусcкие заглавные буквы!";
			Возврат Ложь;
		КонецЕсли;

	ИначеЕсли ТипДока=2 Тогда // серия - две буквы: военный билет, ...

		Если (СтрДлина(Серия) <> 2) ИЛИ (ПустаяСтрока(ЗаменитьОдниСимволыДругими("АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ",Серия,"                                 "))=0) Тогда
			СтрОшибка = "В серии документа должны быть ДВЕ pусcкие заглавные буквы!";
			Возврат Ложь;
		КонецЕсли;

	ИначеЕсли ТипДока=3 Тогда // серия - две цифры: загранпаспорта 

		Если (СтрДлина(Серия) <> 2) ИЛИ (ПустаяСтрока(ЗаменитьОдниСимволыДругими("0123456789",Серия,"          "))=0) Тогда
			СтрОшибка = "В серии документа должно быть ДВЕ цифры!";
			Возврат Ложь;
		КонецЕсли;

	ИначеЕсли ТипДока=4 Тогда // серия - две группы цифр: новый паспорт
		
		Поз = Найти(Серия," ");
		Если Поз=0 Тогда
			СтрОшибка = "В серии документа должно быть две группы цифр!";
			Возврат Ложь;
		КонецЕсли;

		ПервЧасть = Лев(Серия,Поз-1);
		ВторЧасть = СокрЛП(Сред(Серия,Поз+1));

		Поз = Найти(ВторЧасть," ");
		Если Поз <> 0 Тогда
			СтрОшибка = "В серии документа должно быть только две группы цифр!";
			Возврат Ложь;
		КонецЕсли;

		Если (СтрДлина(ПервЧасть) <> 2) ИЛИ
			(ПустаяСтрока(ЗаменитьОдниСимволыДругими("0123456789",ПервЧасть,"          "))=0) Тогда
			СтрОшибка = "Первая группа символов серии документа должна содержать две цифры!";
			Возврат Ложь;
		КонецЕсли;

		Если (СтрДлина(ВторЧасть) <> 2) ИЛИ
			(ПустаяСтрока(ЗаменитьОдниСимволыДругими("0123456789",ВторЧасть,"          "))=0) Тогда
			СтрОшибка = "Вторая группа символов серии документа должна содержать две цифры!";
			Возврат Ложь;
		КонецЕсли;
	   
	КонецЕсли;

	Возврат Истина;
КонецФункции 

// Проверяет соответствие ИНН требованиям
// Параметры:
//		ИНН - строка - проверяемый индивидуальный номер налогоплательщика,
//		ВладелецИНН - ПеречислениеСсылка.ЮрФизЛицо - тип владельца ИНН: физлицо или юрлицо
Функция ИННСоответствуетТребованиям(Знач ИНН, ВладелецИНН) Экспорт

	ИНН = СокрЛП(ИНН);
	ДлинаИНН =  СтрДлина(ИНН);
	
	ИННбезНулей = СтрЗаменить(ИНН,"0","1");
	Попытка
	    ЧислоИНН = Число(ИННбезНулей);
	Исключение
		Возврат Ложь;// В ИНН имеются символы, отличные от цифр (0..9)
	КонецПопытки; 
	
	
	Если ДлинаИНН =10  и ВладелецИНН = Перечисления.ЮрФизЛицо.ЮрЛицо Тогда
		
		КонтрольнаяСумма = 0;
		
		Для Н=1 По 9 Цикл
			
			Если 	  Н = 1 Тогда
				Множитель = 2;
			ИначеЕсли Н = 2 Тогда
				Множитель = 4;
			ИначеЕсли Н = 3 Тогда
				Множитель = 10;
			ИначеЕсли Н = 4 Тогда
				Множитель = 3;
			ИначеЕсли Н = 5 Тогда
				Множитель = 5;
			ИначеЕсли Н = 6 Тогда
				Множитель = 9;
			ИначеЕсли Н = 7 Тогда
				Множитель = 4;
			ИначеЕсли Н = 8 Тогда
				Множитель = 6;
			ИначеЕсли Н = 9 Тогда
				Множитель = 8;
			КонецЕсли; 
			
			Цифра = Число(Сред(ИНН,Н,1));
			КонтрольнаяСумма = КонтрольнаяСумма + Цифра * Множитель;
			
		КонецЦикла; 
		
		КонтрольныйРазряд = (КонтрольнаяСумма %11) %10;
		
		Если КонтрольныйРазряд <> Число(Сред(ИНН,10,1)) Тогда
			Возврат Ложь;
		КонецЕсли; 
		
	ИначеЕсли ДлинаИНН =12 и ВладелецИНН = Перечисления.ЮрФизЛицо.ФизЛицо Тогда
		
		КонтрольнаяСумма11 = 0;
		КонтрольнаяСумма12 = 0;
		
		Для Н=1 По 11 Цикл
			
			// Расчет множителя для 11-го и 12-го разрядов
			Если Н = 1 Тогда
				Множитель11 = 7;
				Множитель12 = 3;
			ИначеЕсли Н = 2 Тогда
				Множитель11 = 2;
				Множитель12 = 7;
			ИначеЕсли Н = 3 Тогда
				Множитель11 = 4;
				Множитель12 = 2;
			ИначеЕсли Н = 4 Тогда
				Множитель11 = 10;
				Множитель12 = 4;
			ИначеЕсли Н = 5 Тогда
				Множитель11 = 3;
				Множитель12 = 10;
			ИначеЕсли Н = 6 Тогда
				Множитель11 = 5;
				Множитель12 = 3;
			ИначеЕсли Н = 7 Тогда
				Множитель11 = 9;
				Множитель12 = 5;
			ИначеЕсли Н = 8 Тогда
				Множитель11 = 4;
				Множитель12 = 9;
			ИначеЕсли Н = 9 Тогда
				Множитель11 = 6;
				Множитель12 = 4;
			ИначеЕсли Н = 10 Тогда
				Множитель11 = 8;
				Множитель12 = 6;
			ИначеЕсли Н = 11 Тогда
				Множитель11 = 0;
				Множитель12 = 8;
			КонецЕсли; 
			
			Цифра = Число(Сред(ИНН,Н,1));
			КонтрольнаяСумма11 = КонтрольнаяСумма11 + Цифра * Множитель11;
			КонтрольнаяСумма12 = КонтрольнаяСумма12 + Цифра * Множитель12;
			
		КонецЦикла; 
		
		КонтрольныйРазряд11 = (КонтрольнаяСумма11 %11) %10;
		КонтрольныйРазряд12 = (КонтрольнаяСумма12 %11) %10;
		
		Если КонтрольныйРазряд11 <> Число(Сред(ИНН,11,1))
			ИЛИ КонтрольныйРазряд12 <> Число(Сред(ИНН,12,1)) Тогда
			Возврат Ложь;
		КонецЕсли; 
		
	Иначе	
		
		Возврат Ложь;
		
	КонецЕсли; 
	
	Возврат Истина;
	
КонецФункции

//Проверяет номер страхового свидетельства на соответствие требованиям ПФР
Функция СтраховойНомерПФРСоответствуетТребованиям(СтраховойНомер) Экспорт
	
	Результат = Истина;
	
	СтрокаЦифр=СтрЗаменить(Лев(СтраховойНомер,11),"-","");
	
	Попытка
		П1 = Число(СтрокаЦифр);	
		КонтрольноеЧисло=Число(Прав(СтраховойНомер,2));
	Исключение
		Возврат Ложь;
	КонецПопытки; 
	
	Если ПустаяСтрока(СтрокаЦифр)=0  Тогда
		Если Число(Лев(СтрокаЦифр,9)) > 1001998 Тогда
			Всего=0;
			Для Сч = 1 По 9 Цикл
				Всего=Всего+Число(Сред(СтрокаЦифр,10-Сч,1))*Сч
			КонецЦикла;
			Остаток=Всего%101;
			Остаток=?(Остаток=100,0,Остаток);
			Если Остаток<>КонтрольноеЧисло Тогда
				Результат = Ложь;
			КонецЕсли;
		КонецЕсли;
	Иначе
		Результат = Ложь;
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

//Определяет соответствие основных параметров адреса требованиям МНС
Функция АдресСоответствуетТребованиям(Знач СтруктураАдрес) Экспорт
	
	Город = СтруктураАдрес.Город;
	Город = СтрЗаменить(Город,"с/с","");
	Город = СтрЗаменить(Город,"с/а","");  
	Город = СтрЗаменить(Город,"с/мо","");
	Город = СтрЗаменить(Город,"с/о",""); 
	НаселенныйПункт = СтруктураАдрес.НаселенныйПункт;
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"ж/д_","");
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"ж/д","");  
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"п/р","");
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"п/ст",""); 
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"п/о",""); 

	// Элементы классификатора KLADR. Встречаются элементы с "/". "(", ")".
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"/","");
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"(",""); 
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,")",""); 

	Улица = СтруктураАдрес.Улица; 

	// Элементы классификатора сокращений.
	Улица = СтрЗаменить(Улица,"ж/д_","");
	Улица = СтрЗаменить(Улица,"ж/д","");  
	Улица = СтрЗаменить(Улица,"п/о","");
	Улица = СтрЗаменить(Улица,"п/ст",""); 
	Улица = СтрЗаменить(Улица,"п/р","");

	// Элементы классификатора STREET. Встречаются улицы с "/". "(", ")". 
	Улица = СтрЗаменить(Улица,"/","");
	Улица = СтрЗаменить(Улица,"(","");
	Улица = СтрЗаменить(Улица,")","");

	Если СтруктураАдрес.Количество()<>10 Тогда // должно быть 10 элементов
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Страна) > 3  Тогда   // код страны не > 3 символов
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Индекс) > 6  Тогда   // индекс не > 6 символов
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Регион) > 30 Тогда   // наим.региона не > 30 символов
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Район) > 35 Тогда   // наим.района не > 35 символов
		Возврат Ложь;
	ИначеЕсли НЕ СтрокаНаписанаПоРусски(СтруктураАдрес.Район) Тогда   // наим.района написано не русскими буквами
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Город) > 35 Тогда   // наим.города не > 35 символов
		Возврат Ложь;
	ИначеЕсли НЕ СтрокаНаписанаПоРусски(Город) Тогда   // наим.города написано не русскими буквами
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.НаселенныйПункт) > 45 Тогда   // наим.нас.пункта не > 45 символов
		Возврат Ложь;
	ИначеЕсли НЕ СтрокаНаписанаПоРусски(НаселенныйПункт) Тогда   // наим.нас.пункта написано не русскими буквами
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Улица) > 45 Тогда   // наим.улицы не > 45 символов
		Возврат Ложь;
	ИначеЕсли НЕ СтрокаНаписанаПоРусски(Улица) Тогда   // наим.улицы написано не русскими буквами
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Дом) > 10 Тогда   // номер дома не > 10 символов
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Корпус) > 10 Тогда   // номер корпуса не > 10 символов
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Квартира)> 10 Тогда   // номер квартиры не > 10 символов
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции	

//==================================================================================
// ПРОЦЕДУРЫ ВЫБОРКИ ДАННЫХ 

// Возвращает сокращенный уникальный идентификатор текущей конфигурации.
Функция ИДКонфигурации() Экспорт
	Если Метаданные.Имя = "БухгалтерияПредприятия" Тогда
		Возврат "БП";
	ИначеЕсли Метаданные.Имя = "ЗарплатаИУправлениеПерсоналом" Тогда
		Возврат "ЗУП";
	ИначеЕсли Метаданные.Имя = "УправлениеПроизводственнымПредприятием" Тогда
		Возврат "УПП";
	Иначе
		Возврат Метаданные.Имя;
	КонецЕсли;
КонецФункции // ИДКонфигурации()

// Извлекает сведения об организации по списку, переданному в параметре.
// 
// Параметры:
//  Показатели     - Список значений. Содержит в виде представлений перечень 
//                   сведений, которые надо получить. В первом элемент списка
//                   
// 
// Описание:
//  Функция умеет обрабатывать следующие мнемонические имена:
//  ФИОРук
//  ИННРук
//  ФИОБух
//  ИННБух
//
//
Функция ПолучитьСведенияОбОрганизации(Организация, ДатаЗначения, СписокПоказателей) Экспорт

	Перем ОргСведения;
	Перем Значение;

	// Структура, в которой будут возвращаться найденные значения
	ОргСведения = Новый Структура;

	Для каждого ЭлементСписка Из СписокПоказателей Цикл
		ИмяПоказателя = ЭлементСписка.Представление;

		Если ИмяПоказателя = "ФИОРук" Тогда
			Данные = Новый Структура("СтруктурнаяЕдиница",Организация, 
			                         "ОтветственноеЛицо", Перечисления.ОтветственныеЛицаОрганизации.Руководитель);

			ОтвЛица = РегистрыСведений.ОтветственныеЛицаОрганизации.СрезПоследних(ДатаЗначения, Данные);

			Результат = ОтвЛица.Найти(Перечисления.ОтветственныеЛицаОрганизации.Руководитель);

			Если Результат <> Неопределено Тогда
				Значение = Результат.ФизическоеЛицо;
			КонецЕсли;

		ИначеЕсли ИмяПоказателя = "ИННРук" Тогда

			Данные = Новый Структура("СтруктурнаяЕдиница",Организация, 
			                         "ОтветственноеЛицо", Перечисления.ОтветственныеЛицаОрганизации.Руководитель);

			ОтвЛица = РегистрыСведений.ОтветственныеЛицаОрганизации.СрезПоследних(ДатаЗначения, Данные);

			Результат = ОтвЛица.Найти(Перечисления.ОтветственныеЛицаОрганизации.Руководитель);

			Если Результат <> Неопределено Тогда
				Значение = Результат.ФизическоеЛицо.ИНН;
			КонецЕсли;

		ИначеЕсли ИмяПоказателя = "ФИОБух" Тогда
			Данные = Новый Структура("СтруктурнаяЕдиница",Организация, 
			                         "ОтветственноеЛицо", Перечисления.ОтветственныеЛицаОрганизации.ГлавныйБухгалтер);

			ОтвЛица = РегистрыСведений.ОтветственныеЛицаОрганизации.СрезПоследних(ДатаЗначения, Данные);

			Результат = ОтвЛица.Найти(Перечисления.ОтветственныеЛицаОрганизации.ГлавныйБухгалтер);

			Если Результат <> Неопределено Тогда
				Значение = Результат.ФизическоеЛицо;
			КонецЕсли;

		ИначеЕсли ИмяПоказателя = "ИННБух" Тогда
			Данные = Новый Структура("СтруктурнаяЕдиница",Организация, 
			                         "ОтветственноеЛицо", Перечисления.ОтветственныеЛицаОрганизации.ГлавныйБухгалтер);

			ОтвЛица = РегистрыСведений.ОтветственныеЛицаОрганизации.СрезПоследних(ДатаЗначения, Данные);

			Результат = ОтвЛица.Найти(Перечисления.ОтветственныеЛицаОрганизации.ГлавныйБухгалтер);

			Если Результат <> Неопределено Тогда
				Значение = Результат.ФизическоеЛицо.ИНН;
			КонецЕсли;

		Иначе
			Значение = Неопределено;
		КонецЕсли;

		ОргСведения.Вставить(ИмяПоказателя, Значение);

	КонецЦикла;

	Возврат ОргСведения;

КонецФункции // ПолучитьСведенияОбОрганизации()

//Функция возвращает информацию об ответственных лицах организации и их должностях 
Функция ОтветственныеЛицаОрганизаций(Организация, ДатаСреза, Исполнитель = Неопределено) Экспорт

	Результат = Новый Структура("Руководитель, РуководительДолжность, ГлавныйБухгалтер, Кассир, Исполнитель, ИсполнительДолжность, ОтветственныйЗаРегистры");

	Если Организация <> Неопределено тогда

		ЗапросПоЛицам = Новый Запрос();
		ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
		ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
		ЗапросПоЛицам.Текст = "
		|ВЫБРАТЬ
		|	ОтветственныеЛицаОрганизацииСрезПоследних.ОтветственноеЛицо,
		|	ОтветственныеЛицаОрганизацииСрезПоследних.Должность.Наименование КАК Должность,
		|	ВЫБОР КОГДА (ФИОФизЛицСрезПоследних.ФизЛицо) ЕСТЬ NULL  ТОГДА ОтветственныеЛицаОрганизацииСрезПоследних.ФизическоеЛицо.Наименование ИНАЧЕ ФИОФизЛицСрезПоследних.Фамилия + ВЫБОР КОГДА ПОДСТРОКА(ФИОФизЛицСрезПоследних.Имя, 1, 1) <> """" ТОГДА "" "" + ПОДСТРОКА(ФИОФизЛицСрезПоследних.Имя, 1, 1) + ""."" ИНАЧЕ """" КОНЕЦ + ВЫБОР КОГДА ПОДСТРОКА(ФИОФизЛицСрезПоследних.Отчество, 1, 1) <> """" ТОГДА "" "" + ПОДСТРОКА(ФИОФизЛицСрезПоследних.Отчество, 1, 1) + ""."" ИНАЧЕ """" КОНЕЦ КОНЕЦ КАК ФИОПолное
		|ИЗ
		|	РегистрСведений.ОтветственныеЛицаОрганизации.СрезПоследних(&ДатаСреза, СтруктурнаяЕдиница = &Организация) КАК ОтветственныеЛицаОрганизацииСрезПоследних
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ) КАК ФИОФизЛицСрезПоследних
		|		ПО ОтветственныеЛицаОрганизацииСрезПоследних.ФизическоеЛицо = ФИОФизЛицСрезПоследних.ФизЛицо";
		Выборка = ЗапросПоЛицам.Выполнить().Выбрать();

		Пока Выборка.Следующий() Цикл

			Если Выборка.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизации.Руководитель Тогда
				Результат.Руководитель            = Выборка.ФИОПолное;
				Результат.РуководительДолжность   = Выборка.Должность;

			ИначеЕсли Выборка.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизации.ГлавныйБухгалтер Тогда
				Результат.ГлавныйБухгалтер        = Выборка.ФИОПолное;

			ИначеЕсли Выборка.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизации.Кассир Тогда
				Результат.Кассир                  = Выборка.ФИОПолное;

			КонецЕсли;

		КонецЦикла;

		Если Исполнитель <> Неопределено тогда

			ЗапросПоИсполнителям = Новый Запрос();
			ЗапросПоИсполнителям.УстановитьПараметр("Организация",         Организация);
			ЗапросПоИсполнителям.УстановитьПараметр("ДатаСреза",           ДатаСреза);
			ЗапросПоИсполнителям.УстановитьПараметр("Исполнитель",         Исполнитель);
			ЗапросПоИсполнителям.УстановитьПараметр("ОсновноеМестоРаботы", Перечисления.ВидыЗанятостиВОрганизации.ОсновноеМестоРаботы);
			ЗапросПоИсполнителям.Текст = "
			|ВЫБРАТЬ
			|	РаботникиОрганизацииСрезПоследних.Должность.Наименование КАК Должность,
			|	ВЫБОР КОГДА (ФИОФизЛицСрезПоследних.ФизЛицо) ЕСТЬ NULL ТОГДА
			|		РаботникиОрганизацииСрезПоследних.Физлицо.Наименование
			|	ИНАЧЕ
			|		ФИОФизЛицСрезПоследних.Фамилия
			|		+	ВЫБОР КОГДА ПОДСТРОКА(ФИОФизЛицСрезПоследних.Имя, 1, 1) <> """" ТОГДА
			|				"" "" + ПОДСТРОКА(ФИОФизЛицСрезПоследних.Имя, 1, 1) + "".""
			|			ИНАЧЕ
			|				""""
			|			КОНЕЦ
			|		+ 	ВЫБОР КОГДА ПОДСТРОКА(ФИОФизЛицСрезПоследних.Отчество, 1, 1) <> """" ТОГДА
			|				"" "" + ПОДСТРОКА(ФИОФизЛицСрезПоследних.Отчество, 1, 1) + "".""
			|			ИНАЧЕ
			|				""""
			|			КОНЕЦ
			|		КОНЕЦ КАК ФИОПолное
			|ИЗ
			|	РегистрСведений.РаботникиОрганизации.СрезПоследних(&ДатаСреза, ПодразделениеОрганизации.Владелец = &Организация И ФизЛицо = &Исполнитель) КАК РаботникиОрганизацииСрезПоследних
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ) КАК ФИОФизЛицСрезПоследних
			|		ПО РаботникиОрганизацииСрезПоследних.Физлицо = ФИОФизЛицСрезПоследних.ФизЛицо
			|
			|ГДЕ
			|	РаботникиОрганизацииСрезПоследних.Приказ.ВидЗанятости = &ОсновноеМестоРаботы";
			ВыборкаИсполнителей = ЗапросПоИсполнителям.Выполнить().Выбрать();

			Если ВыборкаИсполнителей.Следующий() тогда
				Результат.ИсполнительДолжность = ВыборкаИсполнителей.Должность;
				Результат.Исполнитель          = ВыборкаИсполнителей.ФиоПолное;
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	Возврат Результат;

КонецФункции // ОтветственныеЛицаОрганизации()

#Если Клиент Тогда

// записывает в рег-р сведений новые фамилию, имя и отчество
Процедура ЗаписатьДанныеФИОВРегистр(Ссылка, Фамилия, Имя, Отчество) Экспорт
	
	ФИОСрез = РегистрыСведений.ФИОФизЛиц.ПолучитьПоследнее(,Новый Структура("ФизЛицо",Ссылка));
	
	СтрокаСреза = ФИОСрез.Фамилия + ФИОСрез.Имя + ФИОСрез.Отчество;
	
	Если СтрокаСреза <> (Фамилия + Имя + Отчество) Тогда
		
		МенеджерЗаписи = РегистрыСведений.ФИОФизЛиц.СоздатьМенеджерЗаписи();
		
		МенеджерЗаписи.ФизЛицо = Ссылка;
		Если ПустаяСтрока(СтрокаСреза) Тогда
			МенеджерЗаписи.Период = '19000101';
		Иначе
			МенеджерЗаписи.Период = РабочаяДата;
		КонецЕсли;
		
		МенеджерЗаписи.Фамилия = Фамилия;
		МенеджерЗаписи.Имя = Имя;
		МенеджерЗаписи.Отчество = Отчество;
		
		МенеджерЗаписи.Записать(Истина);
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает пользовательское представление адреса в формате "9 запятых" по переданному в качестве
// параметра внутреннему представлению.
// Параметры:
//		АдресВФормате9Запятых - строка, внутренне представление адреса в формате "9 запятых".
// Возвращаемое значение:
//		Строка - пользовательское представление адреса в формате "9 запятых".
//		АнализироватьРегион - если Истина, то анализируется переданный регион, на предмет
//				             содержания цифр в коде региона, если цифры есть то вместо них
//				             подставляется текст региона, если не цифры, то остается как есть.
//				             если Ложь, то регион не анализируется.
//
Функция ПредставлениеАдресаВФормате9Запятых(Знач АдресВФормате9Запятых, АнализироватьРегион = Ложь) Экспорт
	
	Если СтрЧислоВхождений(АдресВФормате9Запятых, ",") <> 9 ИЛИ (Лев(АдресВФормате9Запятых, 3) <> "643" И Лев(АдресВФормате9Запятых, 3) <> "999") Тогда
		Возврат АдресВФормате9Запятых;
	КонецЕсли;
	
	КопияАдреса = АдресВФормате9Запятых;
	
	ПоследняяКоордината = 0;
	СоставляющиеАдреса = Новый Массив;
	КоординатыЗапятых = Новый Массив;
	Для Сч = 1 По 9 Цикл
		КоординатаЗапятой = Найти(КопияАдреса, ",");
		КоординатыЗапятых.Добавить(ПоследняяКоордината + КоординатаЗапятой);
		ПоследняяКоордината = ПоследняяКоордината + КоординатаЗапятой;
		КопияАдреса = Сред(КопияАдреса, КоординатаЗапятой + 1);
	КонецЦикла;
	
	СоставляющиеАдреса.Добавить(СокрЛП(Лев(АдресВФормате9Запятых, КоординатыЗапятых[0] - 1)));
	Для Сч = 0 По 7 Цикл
		СоставляющиеАдреса.Добавить(СокрЛП(Сред(АдресВФормате9Запятых, КоординатыЗапятых[Сч] + 1, КоординатыЗапятых[Сч + 1] - (КоординатыЗапятых[Сч] + 1))));
	КонецЦикла;
	СоставляющиеАдреса.Добавить(СокрЛП(Сред(АдресВФормате9Запятых, КоординатыЗапятых[8] + 1)));
	
	ТекПредставление = "";

	Если СокрЛП(СоставляющиеАдреса[1]) <> "" Тогда
		ТекПредставление = ТекПредставление + ", " + СокрЛП(СоставляющиеАдреса[1]);
	КонецЕсли;

	Если СокрЛП(СоставляющиеАдреса[2]) <> "" Тогда
		Регион = СокрЛП(СоставляющиеАдреса[2]);
		Если АнализироватьРегион Тогда
			Если ОбщегоНазначения.ТолькоЦифрыВСтроке(Регион) Тогда
				Регион = ПолучитьНазваниеРегионаПоКоду(Регион);
			КонецЕсли;
		КонецЕсли;

		ТекПредставление = ТекПредставление + ", " + Регион;
	КонецЕсли;

	Если СокрЛП(СоставляющиеАдреса[3]) <> "" Тогда
		ТекПредставление = ТекПредставление + ", " + СокрЛП(СоставляющиеАдреса[3]);
	КонецЕсли;

	Если СокрЛП(СоставляющиеАдреса[4]) <> "" Тогда
		ТекПредставление = ТекПредставление + ", " + СокрЛП(СоставляющиеАдреса[4]);
	КонецЕсли;

	Если СокрЛП(СоставляющиеАдреса[5]) <> "" Тогда
		ТекПредставление = ТекПредставление + ", " + СокрЛП(СоставляющиеАдреса[5]);
	КонецЕсли;

	Если СокрЛП(СоставляющиеАдреса[6]) <> "" Тогда
		ТекПредставление = ТекПредставление + ", " + СокрЛП(СоставляющиеАдреса[6]);
	КонецЕсли;

	Если СокрЛП(СоставляющиеАдреса[7]) <> "" Тогда
		ТекПредставление = ТекПредставление + ", дом № " + СокрЛП(СоставляющиеАдреса[7]);
	КонецЕсли;

	Если СокрЛП(СоставляющиеАдреса[8]) <> "" Тогда
		ТекПредставление = ТекПредставление + ", корпус " + СокрЛП(СоставляющиеАдреса[8]);
	КонецЕсли;

	Если СокрЛП(СоставляющиеАдреса[9]) <> "" Тогда
		ТекПредставление = ТекПредставление + ", кв. " + СокрЛП(СоставляющиеАдреса[9]);
	КонецЕсли;

	Если СтрДлина(ТекПредставление) > 2 Тогда
		ТекПредставление = Сред(ТекПредставление, 3);
	КонецЕсли;
	
	Возврат ТекПредставление;
	
КонецФункции


//==================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФАЙЛАМИ СВЕДЕНИЙ

//Получает текст файла сведений из регистра
Функция ПолучитьТекстФайлаИзРегистра(ДокументСсылка) 

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ДокументСсылка" , ДокументСсылка);

	Запрос.Текст = "ВЫБРАТЬ
	|	АрхивДанныхРегламентированнойОтчетности.Данные
	|ИЗ
	|	РегистрСведений.АрхивДанныхРегламентированнойОтчетности КАК АрхивДанныхРегламентированнойОтчетности
	|
	|ГДЕ
	|	АрхивДанныхРегламентированнойОтчетности.Объект = &ДокументСсылка";

	ВыборкаДанных = Запрос.Выполнить().Выбрать();

	Если ВыборкаДанных.Следующий() тогда
		Возврат ВыборкаДанных.Данные;
	Иначе	
		Возврат "";
	КонецЕсли;	 

КонецФункции	

//Получает текст файла сведений, сформированного по данным документа
Функция ПолучитьТекстФайла(ДокументОбъект,Отказ) Экспорт
	
	Если ДокументОбъект.Проведен тогда
		//Для проведенного документа берём сохраненный ранее текст файла 
		Отказ = Ложь;
		Возврат ПолучитьТекстФайлаИзРегистра(ДокументОбъект.Ссылка);
	Иначе 
		Возврат ДокументОбъект.СформироватьВыходнойФайл(Отказ);
	КонецЕсли;	 
	
КонецФункции	

//Предоставляет сформированный файл сведений документа для просмотра
Процедура ПоказатьФайлДокумента(ДокументОбъект, ЗаголовокОкна) Экспорт

	Вопрос = "Перед формированием файла необходимо записать документ. Записать?";
	Если НЕ ТребованиеЗаписиДокументаУдовлетворено(ДокументОбъект,Вопрос) тогда
		Возврат;
	КонецЕсли;	 

	ЕстьОшибки = Ложь;
	ТекстФайла = ПолучитьТекстФайла(ДокументОбъект,ЕстьОшибки);
	Если ЕстьОшибки тогда
		Возврат;
	КонецЕсли;	 
	
	//Если ТипЗнч(ТекстФайла) = Тип("Строка") Тогда
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.УстановитьТекст(ТекстФайла); 
		ТекстовыйДокумент.Показать(ЗаголовокОкна, "Файл сведений");
	//Иначе //тип("ТекстовыйДокумент")	
	//	ТекстФайла.Показать(ЗаголовокОкна, "Файл сведений");
	//КонецЕсли; 
	
КонецПроцедуры	 

//Записывает файл сведений документа в каталог, указанный пользователем
Процедура ЗаписатьФайлДокументаНаДискету(ДокументОбъект, ТекущийПользователь, ИмяФайла) Экспорт
	
	Вопрос = "Перед формированием файла необходимо записать документ. Записать?";
	Если НЕ ТребованиеЗаписиДокументаУдовлетворено(ДокументОбъект,Вопрос) тогда
		Возврат;
	КонецЕсли;	 

	ЕстьОшибки = Ложь;
	ТекстФайла = ПолучитьТекстФайла(ДокументОбъект,ЕстьОшибки);
	Если ЕстьОшибки тогда
		Возврат;
	КонецЕсли;	 

	Длг = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);

	Длг.Каталог = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекущийПользователь,"ОсновнойКаталогФайлов");
	Длг.Заголовок = "Укажите каталог";

	Если Длг.Выбрать() Тогда
		ИмяФайла = Длг.Каталог+"\" + ИмяФайла;
		//Если ТипЗнч(ТекстФайла) = Тип("Строка") Тогда
			ТекстовыйДокумент = Новый ТекстовыйДокумент;
			ТекстовыйДокумент.УстановитьТекст(ТекстФайла); 
			ТекстовыйДокумент.Записать(ИмяФайла,КодировкаТекста.OEM);
		//Иначе//тип("ТекстовыйДокумент")
		//	ТекстФайла.Записать(ИмяФайла, КодировкаТекста.OEM);
		//КонецЕсли;	
		Предупреждение("Файл-пачка записан под именем: "+ИмяФайла);
	КонецЕсли;
	
КонецПроцедуры	

//Печатает файл сведений документа
Процедура РаспечататьФайлДокумента(ДокументОбъект) Экспорт
	Вопрос = "Перед печатью необходимо записать документ. Записать?";
	Если НЕ ТребованиеЗаписиДокументаУдовлетворено(ДокументОбъект,Вопрос) тогда
		Возврат;
	КонецЕсли;	
	ДокументОбъект.ПечатьФайла();
КонецПроцедуры 

//==================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДИАЛОГАМИ

//Выполняет запись документа в случае подтверждения пользователем
Функция ТребованиеЗаписиДокументаУдовлетворено(ДокументОбъект,ТекстВопросаПодтверждения) Экспорт
	Если ДокументОбъект.ЭтоНовый() или ДокументОбъект.Модифицированность() Тогда
		Ответ  = Вопрос(ТекстВопросаПодтверждения, РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.ОК Тогда
			ДокументОбъект.Записать();
		Иначе
			Возврат ложь;
		КонецЕсли;
	КонецЕсли;
	Возврат Истина;
КонецФункции	 


//==================================================================================
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА ПОДДЕРЖКИ ВНЕШНИХ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ
//

// Функция пытается сравнить объект (внешний регламентированный отчет) в памяти с объектом, 
// находящемся в соответствующем файле в текущем каталоге.
// Если объекты совпадают, функция загружает файл на диске в реквизит ВнешнийОтчетХранилище
// соответствующего элемента справочника РегламентированныеОтчеты.
// Параметры:
//       Объект - объект в памяти, который сравнивается с объектом на диске.
//	Возвращаемое значение:
//		 Булево - Истина, если объект загружен; Ложь в противном случае.
Функция СравнитьИЗалитьВХранилище(Объект)

	ИмяФайлаВнешнегоОтчета = Объект.Метаданные().Имя + ".epf";
	ФайлВнешнегоОтчета = Новый Файл(ИмяФайлаВнешнегоОтчета);
	Если НЕ ФайлВнешнегоОтчета.Существует() Тогда
		Возврат Ложь;
	КонецЕсли;

	Попытка
		ОбъектВнешнийОтчет = ВнешниеОбработки.Создать(ИмяФайлаВнешнегоОтчета);
	Исключение
		Возврат Ложь;
	Конецпопытки;

	Если ОбъектВнешнийОтчет.Метаданные().Имя <> Объект.Метаданные().Имя ИЛИ
			ОбъектВнешнийОтчет.Метаданные().Синоним <> Объект.Метаданные().Синоним ИЛИ
			ОбъектВнешнийОтчет.Метаданные().Комментарий <> Объект.Метаданные().Комментарий ИЛИ
			ЗначениеВСтрокуВнутр(ОбъектВнешнийОтчет.Метаданные()) <> ЗначениеВСтрокуВнутр(Объект.Метаданные()) Тогда

		Возврат Ложь;

	КонецЕсли;

	Если ОбъектВнешнийОтчет.Метаданные().Формы = Неопределено ИЛИ Объект.Метаданные().Формы = Неопределено 
			ИЛИ ОбъектВнешнийОтчет.Метаданные().Формы.Количество() <> Объект.Метаданные().Формы.Количество() Тогда

		Возврат Ложь;

	КонецЕсли;

	Если ОбъектВнешнийОтчет.Метаданные().Макеты = Неопределено И Объект.Метаданные().Макеты <> Неопределено
		ИЛИ ОбъектВнешнийОтчет.Метаданные().Макеты <> Неопределено И Объект.Метаданные().Макеты = Неопределено
		ИЛИ ОбъектВнешнийОтчет.Метаданные().Макеты.Количество() <> Объект.Метаданные().Макеты.Количество() Тогда

		Возврат Ложь;

	КонецЕсли;

	ВремФайлВнешнегоОтчета1 = ПолучитьИмяВременногоФайла();
	Попытка
		КопироватьФайл(ИмяФайлаВнешнегоОтчета, ВремФайлВнешнегоОтчета1);
	Исключение
		Возврат Ложь;
	КонецПопытки;
	НайденныйЭлемент = Справочники.уатРегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Объект.Метаданные().Имя);
	Если НайденныйЭлемент = Справочники.уатРегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Ложь;
	КонецЕсли;
	Если НайденныйЭлемент.ВнешнийОтчетХранилище.Получить() <> Неопределено Тогда
		ВремФайлВнешнегоОтчета2 = ПолучитьИмяВременногоФайла();
		Попытка
			НайденныйЭлемент.ВнешнийОтчетХранилище.Получить().Записать(ВремФайлВнешнегоОтчета2);
			Сравнение = Новый СравнениеФайлов();
			Сравнение.ПервыйФайл = ВремФайлВнешнегоОтчета1;
			Сравнение.ВторойФайл = ВремФайлВнешнегоОтчета2;
			Сравнение.СпособСравнения = СпособСравненияФайлов.Двоичное;
			Если Сравнение.Сравнить() Тогда
				Возврат Ложь;
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;
	Если Вопрос("Отчет, который хранится в информационной базе, отличается от выбранного." + Символы.ПС + "Загрузить выбранный отчет в информационную базу?",
				РежимДиалогаВопрос.ДаНет) = КодВозвратаДиалога.Нет Тогда

		Возврат Ложь;

	КонецЕсли;
	Попытка
		ОбъектНайденныйЭлемент = НайденныйЭлемент.ПолучитьОбъект();
		ОбъектНайденныйЭлемент.ВнешнийОтчетХранилище = Новый ХранилищеЗначения(Новый ДвоичныеДанные(ВремФайлВнешнегоОтчета1), Новый СжатиеДанных(9));
		ОбъектНайденныйЭлемент.ВнешнийОтчетИспользовать = Истина;
		ОбъектНайденныйЭлемент.Записать();
	Исключение
		Предупреждение("Не удалось загрузить выбранный отчет в информационную базу!");
		Возврат Ложь;
	КонецПопытки;
	Предупреждение("Внешний отчет успешно загружен в информационную базу." + 
		?(ОтчетКэшировался(ОбъектНайденныйЭлемент), Символы.ПС + "ИЗМЕНЕНИЯ ВСТУПЯТ В СИЛУ ТОЛЬКО ПОСЛЕ ПОВТОРНОГО ЗАПУСКА ПРОГРАММЫ!", ""));

	ТекОтчет = РеглОтчеты(Объект.Метаданные().Имя);
	ТекФорма = ФормаРеглОтчета(Объект.Метаданные().Имя);
	ТекФорма.РежимВыбора = Ложь;
	ТекФорма.Открыть();
	Возврат Истина;

КонецФункции

// Сравнивает "версию" данных, хранящихся в экземпляре документа РегламентированныйОтчет с 
// "версией" отчета, с помощью которого эти данные пытаются открыть.
// Параметры:
// 		ВерсияФормы - "версия" данных.
//		мВерсияФормы = "версия" отчета.
// Возвращаемое значение:
//		Булево - Истина, если отчет с версией мВерсияФормы способен работать с данными версии ВерсияФормы.
//				 Ложь, если отчет с версией мВерсияФормы НЕ способен работать с данными версии ВерсияФормы.
Функция ПродолжитьПриНесоответствииВерсийФорм(Знач ВерсияФормы, Знач мВерсияФормы) Экспорт
	
	ПервыйСлеш = Найти(ВерсияФормы, "/");
	ВторойСлеш = Найти(Лев(ВерсияФормы, ПервыйСлеш - 1) + " " + Сред(ВерсияФормы, ПервыйСлеш + 1), "/");
	Если ПервыйСлеш = Неопределено ИЛИ ВторойСлеш = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	ГодВерсияФормы = Сред(ВерсияФормы, ВторойСлеш + 1);
	МесяцВерсияФормы = Сред(ВерсияФормы, ПервыйСлеш + 1, ВторойСлеш - ПервыйСлеш - 1);
	ДеньВерсияФормы = Сред(ВерсияФормы, 1, ПервыйСлеш - 1);
	Если СтрДлина(ГодВерсияФормы) = 2 Тогда
		ГодВерсияФормы = "20" + ГодВерсияФормы;
	КонецЕсли;
	Если СтрДлина(МесяцВерсияФормы) = 1 Тогда
		МесяцВерсияФормы = "0" + МесяцВерсияФормы;
	КонецЕсли;
	Если СтрДлина(ДеньВерсияФормы) = 1 Тогда
		ДеньВерсияФормы = "0" + ДеньВерсияФормы;
	КонецЕсли;
	ДатаВерсияФормы = Дата(ГодВерсияФормы + МесяцВерсияФормы + ДеньВерсияФормы);
	
	ПервыйСлеш = Найти(мВерсияФормы, "/");
	ВторойСлеш = Найти(Лев(мВерсияФормы, ПервыйСлеш - 1) + " " + Сред(мВерсияФормы, ПервыйСлеш + 1), "/");
	Если ПервыйСлеш = Неопределено ИЛИ ВторойСлеш = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	ГодмВерсияФормы = Сред(мВерсияФормы, ВторойСлеш + 1);
	МесяцмВерсияФормы = Сред(мВерсияФормы, ПервыйСлеш + 1, ВторойСлеш - ПервыйСлеш - 1);
	ДеньмВерсияФормы = Сред(мВерсияФормы, 1, ПервыйСлеш - 1);
	Если СтрДлина(ГодмВерсияФормы) = 2 Тогда
		ГодмВерсияФормы = "20" + ГодмВерсияФормы;
	КонецЕсли;
	Если СтрДлина(МесяцмВерсияФормы) = 1 Тогда
		МесяцмВерсияФормы = "0" + МесяцмВерсияФормы;
	КонецЕсли;
	Если СтрДлина(ДеньмВерсияФормы) = 1 Тогда
		ДеньмВерсияФормы = "0" + ДеньмВерсияФормы;
	КонецЕсли;
	ДатамВерсияФормы = Дата(ГодмВерсияФормы + МесяцмВерсияФормы + ДеньмВерсияФормы);
	
	Если ДатамВерсияФормы < ДатаВерсияФормы Тогда
		Предупреждение("Сохраненные данные не могут быть открыты текущей версией отчета!" + Символы.ПС + 
						"Версия отчета - от " + Формат(ДатамВерсияФормы, "ДЛФ=DD; ДП='Пустая дата'") + Символы.ПС + 
						"Версия данных - от " + Формат(ДатаВерсияФормы, "ДЛФ=DD; ДП='Пустая дата'"));
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

// Возвращает двоичные данные с файлом - внешней обработкой с учетом кэша (реквизит ВнешнийОтчетХранилище), 
// для переданного в качестве параметра элемента справочника РегламентированныеОтчеты.
// Параметры:
//		РеглОтч - ссылка на элемент справочника РегламентированныеОтчеты.
// Возвращаемое значение:
//		Содержимое реквизита ВнешнийОтчетХранилище элемента справочника с учетом кэша.
Функция ОбъектОтчетСУчетомКэша(РеглОтч)
	Перем ОтчетВКэше;
	
	Попытка
		Кэш = ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов.Получить();
	Исключение
		Кэш = Новый Структура;
	КонецПопытки;
	Если Кэш.Свойство(РеглОтч.ИсточникОтчета, ОтчетВКэше) Тогда
		Возврат ОтчетВКэше.Отчет;
	Иначе
		Попытка
			ОтчетВКэш = РеглОтч.ВнешнийОтчетХранилище.Получить();
			Кэш.Вставить(РеглОтч.ИсточникОтчета, Новый Структура("Отчет, Признак", ОтчетВКэш, РеглОтч.ВнешнийОтчетИспользовать));
			ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов = Новый ХранилищеЗначения(Кэш);
			Возврат ОтчетВКэш;
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	КонецЕсли;
	
КонецФункции

// Возвращает признак использования внешнего отчета с учетом кэша (реквизит ВнешнийОтчетИспользовать), 
// для переданного в качестве параметра элемента справочника РегламентированныеОтчеты.
// Параметры:
//		РеглОтч - ссылка на элемент справочника РегламентированныеОтчеты.
// Возвращаемое значение:
//		Признак использования внешнего отчета для заданного элемента справочника с учетом кэша.
Функция ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(РеглОтч)
	Перем ОтчетВКэше;
	
	Попытка
		Кэш = ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов.Получить();
	Исключение
		Кэш = Новый Структура;
	КонецПопытки;
	Если Кэш.Свойство(РеглОтч.ИсточникОтчета, ОтчетВКэше) Тогда
		Возврат ОтчетВКэше.Признак;
	Иначе
		Попытка
			ВнешнийОтчетИспользовать = РеглОтч.ВнешнийОтчетИспользовать;
			Кэш.Вставить(РеглОтч.ИсточникОтчета, Новый Структура("Отчет, Признак", РеглОтч.ВнешнийОтчетХранилище.Получить(), ВнешнийОтчетИспользовать));
			ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов = Новый ХранилищеЗначения(Кэш);
			Возврат ВнешнийОтчетИспользовать;
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	КонецЕсли;
	
КонецФункции

// Показывает или скрывает (в зависимости от вида отчета) элемент формы, сигнализирующий пользователю
// о том, что текущая форма принадлежит внешнему отчету.
// Параметры:
//		Форма - объект Форма.
Процедура ДобавитьНадписьВнешнийОтчет(Форма) Экспорт
	
	СтроковоеПредставлениеТипаОбъекта = Строка(ТипЗнч(Форма.ЭтотОбъект));
	ЭтоВнешняяОбработка = (Лев(СтроковоеПредставлениеТипаОбъекта, 24) = "Внешняя обработка объект");
	Если ЭтоВнешняяОбработка Тогда
	
		Если Форма.ЭлементыФормы.Найти("_ИндикаторВнешнегоОтчета") = Неопределено Тогда
			Возврат;
		КонецЕсли;
		Форма.ЭлементыФормы._ИндикаторВнешнегоОтчета.Видимость = Истина;
		
	Иначе
		
		Если Форма.ЭлементыФормы.Найти("_ИндикаторВнешнегоОтчета") = Неопределено Тогда
			Возврат;
		КонецЕсли;
		Форма.ЭлементыФормы._ИндикаторВнешнегоОтчета.Видимость = Ложь;
		
	КонецЕсли;
		
КонецПроцедуры

// Создает и возвращает ссылку на объект - регламентированный отчет, соответствующий переданному 
// в качестве параметра наименованию. При создании объекта учитывается информация в кэше.
// Параметры:
//		Наим - строка-идентификатор регламентированного отчета.
//		СоздаватьИНеЗапоминать - признак того, что созданный объект не оставить след в кэше.
// Возвращаемое значение:
//		Отчет или ВнешняяОбработка - созданный объект. В случае неудачи возвращается Неопределено.
Функция РеглОтчеты(Наим, СоздаватьИНеЗапоминать = Ложь) Экспорт
	Перем ВременныйФайл;
	
	НайденныйЭлемент = Справочники.уатРегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Наим);
	Если НайденныйЭлемент = Справочники.уатРегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент) <> Истина ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // используется внутренний отчет
		Если Метаданные.Отчеты.Найти(Наим) <> Неопределено Тогда
			Возврат Отчеты[Наим];
		Иначе
			Сообщить("Не найден отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
			Возврат Неопределено;
		КонецЕсли; 
	Иначе // используется внешний отчет
		
		Попытка
			СтруктураРегламентированныхОтчетов = ПараметрыСеанса.ПолныеИменаФайловВнешнихРегламентированныхОтчетов.Получить();
		Исключение
			СтруктураРегламентированныхОтчетов = Новый Структура;
		КонецПопытки;
		
		Если НЕ СтруктураРегламентированныхОтчетов.Свойство(Наим, ВременныйФайл) ИЛИ ВременныйФайл = Неопределено Тогда
			
			Попытка
				ВременныйФайл = ПолучитьИмяВременногоФайла();
				ОбъектОтчетСУчетомКэша(НайденныйЭлемент).Записать(ВременныйФайл);
				ВнешняяОбработка = ВнешниеОбработки.Создать(ВременныйФайл);
				Попытка
					ВнешняяОбработка.мПолноеИмяФайлаВнешнейОбработки = ВременныйФайл;
				Исключение
				КонецПопытки;
				Если НЕ СоздаватьИНеЗапоминать Тогда
					СтруктураРегламентированныхОтчетов.Вставить(Наим, ВременныйФайл);
					ПараметрыСеанса.ПолныеИменаФайловВнешнихРегламентированныхОтчетов = Новый ХранилищеЗначения(СтруктураРегламентированныхОтчетов);
				КонецЕсли;
				Возврат ВнешняяОбработка;
			Исключение
				Сообщить("Не удалось запустить внешний отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
				Возврат Неопределено;
			Конецпопытки;
			
		Иначе
			
			Попытка
				ОбъектОтчетСУчетомКэша(НайденныйЭлемент).Записать(ВременныйФайл);
				ВнешняяОбработка = ВнешниеОбработки.Создать(ВременныйФайл);
				Попытка
					ВнешняяОбработка.мПолноеИмяФайлаВнешнейОбработки = ВременныйФайл;
				Исключение
				КонецПопытки;
				Возврат ВнешняяОбработка;
			Исключение
				Сообщить("Не удалось запустить внешний отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
				Возврат Неопределено;
			Конецпопытки;
			
		КонецЕсли;
		
	КонецЕсли;
	Возврат Неопределено;
	
КонецФункции

// Создает и возвращает ссылку на форму регламентированного отчета, соответствующего переданному 
// в качестве параметра наименованию. При получении формы учитывается информация в кэше.
// Параметры:
//		Наим - строка-идентификатор регламентированного отчета.
//		ВыбраннаяФорма - строка - имя формы.
//		Владелец - владелец формы. Форма или элемент управления.
//		КлючУникальности - ключ, значение которого будет использовано для поиска уже открытых форм.
// Возвращаемое значение:
//		Форма - созданный объект. В случае неудачи возвращается Неопределено.
Функция ФормаРеглОтчета(Наим, ВыбраннаяФорма = Неопределено, Владелец = Неопределено, КлючУникальности = Неопределено) Экспорт
	Перем ВременныйФайл;
	
	НайденныйЭлемент = Справочники.уатРегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Наим);
	Если НайденныйЭлемент = Справочники.уатРегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент) <> Истина ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // используется внутренний отчет
		Если Метаданные.Отчеты.Найти(Наим) <> Неопределено Тогда
			Возврат Отчеты[Наим].ПолучитьФорму(ВыбраннаяФорма, Владелец, КлючУникальности);
		Иначе
			// отчет с таким именем не найден
			Сообщить("Не найден отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
			Возврат Неопределено;
		КонецЕсли; 
	Иначе // используется внешний отчет
		
		Попытка
			СтруктураРегламентированныхОтчетов = ПараметрыСеанса.ПолныеИменаФайловВнешнихРегламентированныхОтчетов.Получить();
		Исключение
			СтруктураРегламентированныхОтчетов = Новый Структура;
		КонецПопытки;
		
		Если НЕ СтруктураРегламентированныхОтчетов.Свойство(Наим, ВременныйФайл) ИЛИ ВременныйФайл = Неопределено Тогда
			
			Возврат Неопределено;
			//Попытка
			//	ВременныйФайл = ПолучитьИмяВременногоФайла();
			//	НайденныйЭлемент.ВнешнийОтчетХранилище.Получить().Записать(ВременныйФайл);
			//	ВнешняяОбработка = ВнешниеОбработки.Создать(ВременныйФайл);
			//	СтруктураРегламентированныхОтчетов.Вставить(Наим, ВременныйФайл);
			//	ПараметрыСеанса.РегламентированныеОтчеты = Новый ХранилищеЗначения(СтруктураРегламентированныхОтчетов);
			//	Возврат ВнешняяОбработка;
			//Исключение
			//	Сообщить("Не удалось запустить внешний отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
			//	Возврат Неопределено;
			//Конецпопытки;
			
		Иначе
			
			Попытка
				ОбъектОтчетСУчетомКэша(НайденныйЭлемент).Записать(ВременныйФайл);
				ВнешняяОбработка = ВнешниеОбработки.ПолучитьФорму(ВременныйФайл, ВыбраннаяФорма, Владелец, КлючУникальности);
				Попытка
					ВнешняяОбработка.мПолноеИмяФайлаВнешнейОбработки = ВременныйФайл;
				Исключение
				КонецПопытки;
				ДобавитьНадписьВнешнийОтчет(ВнешняяОбработка);
				Возврат ВнешняяОбработка;
			Исключение
				Возврат Неопределено;
			Конецпопытки;
			
		КонецЕсли;
		
	КонецЕсли;
	Возврат Неопределено;
	
КонецФункции

// Определяет, с учетом кэша, является ли отчет, заданный строкой-идентификатором Наим, внешним.
// Параметры:
//		Наим - строка-идентификатор отчета.
// ВозвращаемоеЗначение:
//		Булево - Истина, если для заданной строки-идентификатора используется внешний отчет.
//				 Ложь - в противном случае.
//				 Неопределено - информация по отчету, заданному строкой-идентификатором 
//  			 отсутствует в справочнике РегламентированныеОтчеты.
Функция ЭтоВнешнийОтчет(Наим) Экспорт
	
	НайденныйЭлемент = Справочники.уатРегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Наим);
	Если НайденныйЭлемент = Справочники.уатРегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент) <> Истина ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // внутренний отчет
		Возврат Ложь;
	Иначе // внешний отчет
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

// Определяет кэшировалась ли информация для заданного элемента справочника РегламентированныеОтчеты.
// Параметры:
//		РеглОтч - ссылка на элемент справочника РегламентированныеОтчеты.
// Возвращаемое значение:
// 		Булево - Истина - информация кэшировалась,
// 				 Ложь - в противном случае.
Функция ОтчетКэшировался(РеглОтч) Экспорт
	Перем ОтчетВКэше;
	
	Попытка
		Возврат ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов.Получить().Свойство(РеглОтч.ИсточникОтчета, ОтчетВКэше);
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Пытается заблокировать документ. В случае неудачной попытки выдает предупреждение.
// Параметры:
//		мСохраненныйДок - объект ДокументОбъект, блокировку которого следует выполнить.
// Возвращаемое значение:
// 		Булево - Истина - объект удалось заблокировать,
// 				 Ложь - объект заблокировать не удалось.
Функция ЗаблокироватьДокумент(мСохраненныйДок)
	
	Попытка
		мСохраненныйДок.Заблокировать();
		Возврат Истина;
	Исключение
		Предупреждение("Не удается заблокировать документ!" + Символы.ПС + "Возможно, документ уже открыт другим пользователем!");
		Возврат Ложь;
	Конецпопытки;
			
КонецФункции

//==================================================================================
// СОБЫТИЯ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ
//

// Событие возникает перед открытием основной формы регламентированного отчета.
// В процедуре инициализируются стандартные переменные отчета. Выполняются специфические для
// внешних регламентированных отчетов действия, в случае если отчет внешний.
// Параметры:
//		Форма - основная форма отчета.
//		Отказ - признак отказа от открытия формы.
//		СтандартнаяОбработка - признак стандартной обработки открытия формы.
Процедура ПередОткрытиемОсновнойФормыРегламентиованногоОтчета(Форма, Отказ, СтандартнаяОбработка) Экспорт
	
	СтроковоеПредставлениеТипаОбъекта = Строка(ТипЗнч(Форма.ЭтотОбъект));
	ЭтоВнешняяОбработка = (Лев(СтроковоеПредставлениеТипаОбъекта, 24) = "Внешняя обработка объект");
	Если ЭтоВнешняяОбработка И Форма.мПолноеИмяФайлаВнешнейОбработки = Неопределено Тогда
		Если СравнитьИЗалитьВХранилище(Форма.ЭтотОбъект) Тогда
			Отказ = Истина;
			Возврат;
		КонецЕсли;
		Если Форма.мПолноеИмяФайлаВнешнейОбработки = Неопределено Тогда
			Предупреждение("Внимание, отчет не зарегистрирован! Функция сохранения будет недоступна!");
			Форма.мЗаписьЗапрещена = Истина;
		КонецЕсли;
	КонецЕсли;
	Форма.АвтоЗаголовок = Ложь;

	Если Форма.ВладелецФормы <> Неопределено Тогда
		Если Не Форма.ВладелецФормы.ЭтоНовый() Тогда
			
			// При восстановлении сохраненных данных сразу открываем
			// нужную форму отчета, минуя основную форму.
			Отказ = Истина;

			Форма.мСохраненныйДок = Форма.ВладелецФормы.ДокументОбъект;
			
			// определяем границы периода построения отчета
			Форма.мДатаНачалаПериодаОтчета = НачалоДня(Форма.мСохраненныйДок.ДатаНачала);
			Форма.мДатаКонцаПериодаОтчета  = КонецДня(Форма.мСохраненныйДок.ДатаОкончания);
			
			// в некоторых отчетах (формы баланса, например) переменная мПериодичность не определена
			Попытка
				Форма.мПериодичность = Форма.мСохраненныйДок.Периодичность;
			Исключение
			КонецПопытки;

			// по реквизиту ВыбраннаяФорма документа определяем,
			// какую форму следует открыть
			ВыбраннаяФорма = Форма.ВладелецФормы.ВыбраннаяФорма;
			
			//УжеОткрытаяФорма = Отчеты[ЭтотОбъект.Метаданные().Имя].ПолучитьФорму(?(ПустаяСтрока(ВыбраннаяФорма),
			//ПолучитьФормуДляПериода(мСохраненныйДок.ДатаОкончания), СокрЛП(ВыбраннаяФорма)), , мСохраненныйДок.Ссылка);
			УжеОткрытаяФорма = ФормаРеглОтчета(Форма.ЭтотОбъект.Метаданные().Имя, СокрЛП(ВыбраннаяФорма), , Форма.мСохраненныйДок.Ссылка);
			Если УжеОткрытаяФорма.Открыта() И УжеОткрытаяФорма.мСохраненныйДок.Ссылка = Форма.мСохраненныйДок.Ссылка Тогда
				УжеОткрытаяФорма.Активизировать();
				Возврат;
			КонецЕсли;
			
			Если НЕ ЗаблокироватьДокумент(Форма.мСохраненныйДок) Тогда
				Возврат;
			КонецЕсли;
			
			Если Форма.ЭтотОбъект.Метаданные().Формы.Найти(СокрП(ВыбраннаяФорма)) <> Неопределено Тогда
				ВыбФормаОтчета = Форма.ПолучитьФорму(СокрП(ВыбраннаяФорма), , Форма.мСохраненныйДок.Ссылка);
			Иначе
				// Если не удалось найти форму с таким названием (могла быть переименована),
				// то по умолчанию выдаем текущую (действующую) форму
				ВыбраннаяФорма = Форма.мТаблицаФормОтчета[0].ФормаОтчета;
				ВыбФормаОтчета = Форма.ПолучитьФорму(ВыбраннаяФорма, , Форма.мСохраненныйДок.Ссылка);
			КонецЕсли;
			
			// Попытка получения переменной мВерсияФормы сохраненного документа для сравнения
			// с аналогичной переменной объекта отчет.
			Попытка
				ВерсияФормыДанных = Форма.мСохраненныйДок.ДанныеОтчета.Получить().ВерсияФормы;
				Если НЕ ПродолжитьПриНесоответствииВерсийФорм(ВерсияФормыДанных, ВыбФормаОтчета.мВерсияФормы) Тогда
					Возврат;
				КонецЕсли;
			Исключение
			Конецпопытки;
			
			Форма.мВыбраннаяФорма = ВыбраннаяФорма;

			ДобавитьНадписьВнешнийОтчет(ВыбФормаОтчета);
			ВыбФормаОтчета.РежимВыбора = Ложь;
			ВыбФормаОтчета.Открыть();

		ИначеЕсли Форма.ВладелецФормы.мСкопированаФорма <> Неопределено Тогда
			// Новый документ РегламентированныйОтчет был получен
			// методом копирования имеющегося.
			// Переменной мСохраненныйДок присвоим текущий документ
			Форма.мСохраненныйДок   = Форма.ВладелецФормы.ДокументОбъект;
			Форма.мСкопированаФорма = Форма.ВладелецФормы.мСкопированаФорма;
			
			Если НЕ ЗаблокироватьДокумент(Форма.мСохраненныйДок) Тогда
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
	Иначе

	КонецЕсли;
	
КонецПроцедуры

// Событие возникает после записи из регламентированного отчета информации в экземпляр документа
// РегламентированныйОтчет.
// Параметры:
// 		Форма - форма регламентированного отчета, из которой происходила запись в документ.
Процедура ПослеЗаписиРегламентированногоОтчета(Форма) Экспорт
	
	ЗаблокироватьДокумент(Форма.мСохраненныйДок);
	КартинкаСохранение = Форма.ЭлементыФормы.Найти("КартинкаСохранение");
	Если КартинкаСохранение <> Неопределено Тогда
	    КартинкаСохранение.Видимость = Ложь;
	КонецЕсли;
	
КонецПроцедуры

// Событие возникает перед записью из регламентированного отчета информации в экземпляр документа
// РегламентированныйОтчет.
// Проверяет возможность записи данных в экземпляр документа РегламентированныйОтчет из 
// переданной в качестве параметра Формы регламентированного отчета.
// В случае невозможности записи выдает предупреждение.
// Параметры:
// 		Форма - форма регламентированного отчета, из которой производится попытка записи данных в документ.
// Возвращаемое значение:
//		Булево - Истина, если запись возможна; Ложь - в противном случае.
Функция ПриЗаписиРегламентированногоОтчета(Форма) Экспорт
	
	Если Форма.мЗаписьЗапрещена = Истина Тогда
		Предупреждение("Невозможно сохранить отчет! Воспользуйтесь механизмом внешних регламентированных отчетов, встроенным в конфигурацию!");
		Возврат Ложь;
	КонецЕсли;
	КартинкаСохранение = Форма.ЭлементыФормы.Найти("КартинкаСохранение");
	Если КартинкаСохранение <> Неопределено Тогда
	    КартинкаСохранение.Видимость = Истина;
	КонецЕсли;
	Возврат Истина;
	
КонецФункции

// Событие возникает при закрытии регламентированного отчета
// Параметры:
// 		Форма - закрываемая форма регламентированного отчета.
Процедура ПриЗакрытииРегламентированногоОтчета(Форма) Экспорт
	
	Если Форма.мСохраненныйДок <> Неопределено И Форма.мСохраненныйДок <> ОбщегоНазначения.ПустоеЗначениеТипа(ТипЗнч(Форма.мСохраненныйДок)) И Форма.мСохраненныйДок.Заблокирован() Тогда
		Форма.мСохраненныйДок.Разблокировать();
	КонецЕсли;
	СохранитьЗначение("ИнтервалАвтосохраненияРегламентированнойОтчетности", Форма.мИнтервалАвтосохранения);
	
КонецПроцедуры

// Возвращает номер редакции текущей конфигурации.
//  Номер редакции выделяется из полного номера версии конфигурации 
// и представляет собой все символы до второй точки.
//
Функция РедакцияКонфигурации() Экспорт
	
	Перем Версия;
	Перем ПерваяТочка;

	Версия = Метаданные.Версия;
	ПерваяТочка = Найти(Версия, ".");

	Возврат СокрЛП(Лев(Версия, Найти(Сред(Версия, ПерваяТочка + 1), ".") + ПерваяТочка - 1));

КонецФункции // РедакцияКонфигурации()

// Процедура возвращает название региона по его коду.
Функция ПолучитьНазваниеРегионаПоКоду(КодРег)

	Если ПустоеЗначение(КодРег) Тогда
		Возврат "";
	КонецЕсли;

	Попытка
		КодРегЧисло = Число(КодРег);
	Исключение
		Возврат "";
	КонецПопытки;

	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	АдресныйКлассификатор.КодРегионаВКоде,
	               |	АдресныйКлассификатор.ТипАдресногоЭлемента,
	               |	АдресныйКлассификатор.Наименование,
	               |	АдресныйКлассификатор.Код
	               |ИЗ
	               |	РегистрСведений.АдресныйКлассификатор КАК АдресныйКлассификатор
	               |
	               |ГДЕ
	               |	АдресныйКлассификатор.ТипАдресногоЭлемента = &ТипАдресногоЭлемента И
	               |	АдресныйКлассификатор.КодРегионаВКоде = &КодРегионаВКоде";

	Запрос.УстановитьПараметр("КодРегионаВКоде", КодРегЧисло);
	Запрос.УстановитьПараметр("ТипАдресногоЭлемента", 1);

	Выборка = Запрос.Выполнить().Выбрать();

	Если Выборка.Количество() > 0 Тогда
		
		Выборка.Следующий();
		Возврат УправлениеКонтактнойИнформацией.ПолучитьПолноеНазвание(Выборка.Код);
		
	Иначе

		Возврат "";

	КонецЕсли;

КонецФункции // ПолучитьНазваниеРегионаПоКоду

// Проверяет указанный Реквизит на пустое значение.
// Значение Реквизита сравнивается с пустым значением соответствующего Реквизиту типа.
// Реквизит типа Строка считается пустым, если в нем не содержится значащих символов.
Функция ПустоеЗначение(Реквизит) Экспорт

	Если Реквизит = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;

	Если ТипЗнч(Реквизит) = Тип("Строка") Тогда
		Возврат ПустаяСтрока(Реквизит);
	ИначеЕсли ТипЗнч(Реквизит) = Тип("Число") Тогда
		Если Реквизит = 0 Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь;
		КонецЕсли;
	ИначеЕсли ТипЗнч(Реквизит) = Тип("Дата") Тогда
		Если Реквизит = Дата('00010101') Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;

КонецФункции

#КонецЕсли